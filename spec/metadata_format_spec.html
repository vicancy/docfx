<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Doc-as-Code: Metadata Format Specification </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Doc-as-Code: Metadata Format Specification ">
    <meta name="generator" content="docfx 2.15.0.424">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h1 id="doc-as-code-metadata-format-specification">Doc-as-Code: Metadata Format Specification</h1>
              
<h2 id="0-introduction">0. Introduction</h2>
<h3 id="01-goals-and-non-goals">0.1 Goals and Non-goals</h3>
<ol>
<li>The goal of this document is to define a general format to describe language metadata for programming languages.</li>
<li>The language metadata is designed to be language agnostic and support multiple programming language in a single metadata file.</li>
<li>The main user scenario for language metadata is to generate reference documentation, so this document will discuss how to optimize metadata format for documentation rendering.</li>
<li>This document does <strong>NOT</strong> discuss details of metadata format implementation of a specific programming language.</li>
</ol>
<h3 id="02-terminology">0.2 Terminology</h3>
<p>The key words <strong>MUST</strong>, <strong>MUST NOT</strong>, <strong>REQUIRED</strong>, <strong>SHALL</strong>, <strong>SHALL NOT</strong>, <strong>SHOULD</strong>, <strong>SHOULD NOT</strong>, <strong>RECOMMENDED</strong>,  <strong>MAY</strong>, and <strong>OPTIONAL</strong> in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.</p>
<p>Words in <em>italic</em> imply they are terms defined in an earlier section of this document.</p>
<h2 id="1-items-and-identifiers">1. Items and Identifiers</h2>
<h3 id="11-items">1.1 Items</h3>
<p><em>Item</em> is the basic unit of metadata format. From documentation perspective, each <em>item</em> represents a &quot;section&quot; in the reference documentation. This &quot;section&quot; is the minimum unit that you can cross reference to, or customize in layout and content.</p>
<blockquote><p>When implementing the metadata format for your own language, you can decide which elements are <em>items</em>. For example, usually namespaces, classes, and methods are <em>items</em>. However, you can also make smaller elements such as parameters be items if you want them to be referenceable and customizable.</p>
</blockquote>
<p><em>Items</em> can be hierarchical. One <em>item</em> can have other <em>items</em> as <em>children</em>. For example, in C#, namespaces and classes can have classes and/or methods as <em>children</em>.</p>
<h3 id="12-identifiers">1.2 Identifiers</h3>
<p>Each <em>item</em> has an identifier (ID) which is unique under its parent.</p>
<p>As we&#39;re targeting to support multiple languages, there is no restrictions as to which characters are not allowed in identifiers. However, to make identifiers easier to recognize and resolve in Markdown, it&#39;s not <strong>RECOMMENDED</strong> to have whitespaces in identifiers. Markdown processor <strong>MAY</strong> implement some algorithm to tolerate whitespaces in handwritten Markdown. (Leading and trailing spaces <strong>MUST</strong> be removed from identifier.)</p>
<p>Identifier <strong>MUST</strong> be treated as case-sensitive when comparing equality.</p>
<p>Each <em>item</em> has a unique identifier (UID) which is globally unique. A <em>UID</em> is defined as follows:</p>
<ol>
<li>If an <em>item</em> does not have a <em>parent</em>, its <em>UID</em> is its <em>ID</em>.</li>
<li>Otherwise, its <em>UID</em> is the combination of the <em>UID</em> of its <em>parent</em>, a separator and the <em>ID</em> of the <em>item</em> itself.</li>
</ol>
<p>Valid separators are <code>.</code>, <code>:</code>, <code>/</code> and <code>\</code>.</p>
<p>For example, for a class <code>String</code> under namespace <code>System</code>, its ID is <code>String</code> and UID is <code>System.String</code>.</p>
<blockquote><p>Given the above definition, an <em>item</em>&#39;s UID <strong>MUST</strong> starts with the <em>UID</em> of its parent (and any of its ancestors) and ends with the <em>ID</em> of itself. This is useful to quickly determine whether an <em>item</em> is under another <em>item</em>.</p>
</blockquote>
<h3 id="13-alias">1.3 Alias</h3>
<p><em>Identifier</em> could be very long, which makes it difficult to write by hand in Markdown. For example, it&#39;s easy to create a long <em>ID</em> in C# like this:</p>
<pre><code class="lang-markdown">Format(System.IFormatProvider,System.String,System.Object,System.Object)
</code></pre><p>We can create short <em>alias</em> for <em>items</em> so that they can be referenced easily.</p>
<p><em>Alias</em> is same as <em>ID</em>, except:</p>
<ol>
<li>It doesn&#39;t have to be unique.</li>
<li>One <em>item</em> can have multiple <em>aliases</em>.</li>
</ol>
<blockquote><p>It&#39;s not <strong>RECOMMENDED</strong> to create an <em>alias</em> that has nothing to do with an <em>item&#39;s</em> <em>ID</em>. Usually an <em>item</em>&#39;s <em>alias</em> is part of its <em>ID</em> so it&#39;s easy to recognize and memorize.<br>For example, for the case above, we usually create an alias <code>Format()</code>.</p>
</blockquote>
<p>We can easily get a &quot;global&quot; alias for an <em>item</em> by replacing the <em>ID</em> part of its <em>UID</em> with its alias.</p>
<h2 id="2-file-structure">2. File Structure</h2>
<h3 id="21-file-format">2.1 File Format</h3>
<p>You can use any file format that can represent structural data to store metadata. However, we recommend using <a href="http://www.yaml.org/">YAML</a> or <a href="http://www.json.org/">JSON</a>. In this document, we use YAML in examples, but all YAML can be converted to JSON easily.</p>
<h3 id="22-file-layout">2.2 File Layout</h3>
<p>A metadata file consists of two parts: An &quot;item&quot; section and a &quot;reference&quot; section. Each section is a list of objects and each object is a key-value pair (hereafter referred to as &quot;property&quot;) list that represents an <em>item</em>.</p>
<h3 id="23-item-section">2.3 Item Section</h3>
<p>Though <em>items</em> can be hierarchical, they are flat in an <em>item</em> section. Instead, each <em>item</em> has a &quot;children&quot; <em>property</em> indicating its <em>children</em> and a &quot;parent&quot; <em>property</em> indicating its parent.</p>
<p>An <em>item</em> object has some basic properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>uid</td>
<td><strong>REQUIRED</strong>. The <em>unique identifier</em> of the <em>item</em>.</td>
</tr>
<tr>
<td>children</td>
<td><strong>OPTIONAL</strong>. A list of <em>UIDs</em> of the <em>item</em>&#39;s children. Can be omitted if there are no <em>children</em>.</td>
</tr>
<tr>
<td>parent</td>
<td><strong>OPTIONAL</strong>. The <em>UID</em> of the <em>item</em>&#39;s parent. If omitted, metadata parser will try to figure out its <em>parent</em> from the <em>children</em> information of other <em>items</em> within the same file.</td>
</tr>
</tbody>
</table>
<p>Here is an example of a YAML format metadata file for C# Object class:</p>
<pre><code class="lang-yaml">items:
- uid: System.Object
  parent: System
  children:
  - System.Object.Object()
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.Finalize()
  - System.Object.GetHashCode()
  - System.Object.GetType()
  - System.Object.MemberwiseClone()
  - System.Object.ReferenceEquals()
  - System.Object.ToString()
- uid: System.Object.Object()
  parent: System.Object
- uid: System.Object.Equals(System.Object)
  parent: System.Object
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
- uid: System.Object.Finalize()
  parent: System.Object
- uid: System.Object.GetHashCode()
  parent: System.Object
- uid: System.Object.GetType()
  parent: System.Object
- uid: System.Object.MemberwiseClone()
  parent: System.Object
- uid: System.Object.ReferenceEquals()
  parent: System.Object
- uid: System.Object.ToString()
  parent: System.Object
references:
...
</code></pre><blockquote><p><em>Items</em> <strong>SHOULD</strong> be organized based upon how they will display in documentation. For example, if you want all members of a class be displayed in a single page, put all members in a single metadata file.</p>
</blockquote>
<h3 id="23-item-object">2.3 Item Object</h3>
<p>In additional to the <em>properties</em> listed in last section, <em>item object</em> also has some <strong>OPTIONAL</strong> <em>properties</em>:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>The <em>identifier</em> of the <em>item</em>.</td>
</tr>
<tr>
<td>alias</td>
<td>A list of <em>aliases</em> of the <em>item</em>.</td>
</tr>
<tr>
<td>name</td>
<td>The display name of the <em>item</em>.</td>
</tr>
<tr>
<td>fullName</td>
<td>The full display name of the <em>item</em>. In programming languages, it&#39;s usually the full qualified name.</td>
</tr>
<tr>
<td>type</td>
<td>The type of the <em>item</em>, such as class, method, etc.</td>
</tr>
<tr>
<td>url</td>
<td>If it&#39;s a relative URL, then it&#39;s another metadata file that defines the <em>item</em>. If it&#39;s an absolute URL, it means the <em>item</em> is coming from an external library, and the URL is the documentation page of this <em>item</em>. If omitted, the URL is the location of the current file.</td>
</tr>
<tr>
<td>source</td>
<td>The source code information of the <em>item</em>. It&#39;s an object that contains following <em>properties</em>:<br>1. repo: The remote Git repository of the source code.<br>2. branch: the branch of the source code.<br>3. revision: The Git revision of the source code.<br>4. path: the path to the source code file where the <em>item</em> is defined.<br>5. startLine: the start line of the <em>item</em> definition.<br>6. endLine: the end line of the <em>item</em> definition.</td>
</tr>
</tbody>
</table>
<p>Here is an example of a C# Dictionary class:</p>
<pre><code class="lang-yaml">- uid: System.Collections.Generic.Dictionary`2
  id: Dictionary`2
  alias:
  - Dictionary
  parent: System.Collections.Generic
  name: Dictionary&lt;TKey, TValue&gt;
  fullName: System.Collections.Generic.Dictionary&lt;TKey, TValue&gt;
  type: class
  url: System.Collections.Generic.Dictionary`2.yml
  source:
    repo: https://github.com/dotnet/netfx.git
    branch: master
    revision: 5ed47001acfb284a301260271f7d36d2bb014432
    path: src/system/collections/generic/dictionary.cs
    startLine: 1
    endLine: 100
</code></pre><h3 id="24-custom-properties">2.4 Custom Properties</h3>
<p>Besides the predefined <em>properties</em>, <em>item</em> can have its own <em>properties</em>. One restriction is <em>property</em> name <strong>MUST NOT</strong> contains dots, as dot in <em>property</em> name will have special meaning (described in later section).</p>
<h3 id="25-reference-section">2.5 Reference Section</h3>
<p>Reference section also contains a list of <em>items</em>. These <em>items</em> serve as the references by <em>items</em> in <em>item section</em> and won&#39;t show up in documentation. Also, reference <em>item</em> doesn&#39;t need to have full <em>properties</em>, it just contains necessary information needed by its referrer (for example, name or URL).</p>
<p>In metadata file, all <em>items</em> <strong>MUST</strong> be referenced by <em>UID</em>.</p>
<blockquote><p>It&#39;s <strong>RECOMMENDED</strong> to include all referenced <em>items</em> in reference section. This makes the file self-contained and easy to render at runtime.</p>
</blockquote>
<blockquote><p>Many programming languages have the concept of &quot;template instantiation&quot;. For example, in C#, you can create a new type <code>List&lt;int&gt;</code> from <code>List&lt;T&gt;</code> with argument <code>int</code>. You can create a reference for &quot;template instances&quot;. For example, for a class inherited from <code>List&lt;int&gt;</code>:</p>
</blockquote>
<pre><code class="lang-yaml">items:
- uid: NumberList
  inherits:
  - System.Collections.Generic.List&lt;System.Int32&gt;
references:
- uid: System.Collections.Generic.List`1&lt;System.Int32&gt;
  link: @&quot;System.Collections.Generic.List`1&quot;&lt;@&quot;System.Int32&quot;&gt;
- uid: System.Collections.Generic.List`1
  name: List
  url: system.collections.generic.list`1.yml
- uid: System.Int32
  name: int
  url: system.int32.yml
</code></pre><h3 id="26-multiple-language-support">2.6 Multiple Language Support</h3>
<p>An <em>item</em> may need to support multiple languages. For example, in .NET, a class can be used in C#, VB, managed C++ and F#. Different languages may have differences in <em>properties</em>. For example, a list of string is displayed as <code>List&lt;string&gt;</code> in C#, while <code>List(Of string)</code> in VB.</p>
<p>To support this scenario, we introduce a concept of language context to allow defining different <em>property</em> values in different languages.</p>
<p>If a <em>property</em> name is in the form of <code>property_name.language_name</code>, it defines the value of <code>property_name</code> under <code>language_name</code>. For example:</p>
<pre><code class="lang-yaml">- uid: System.Collections.Generic.Dictionary`2
  name.csharp: Dictionary&lt;TKey, TValue&gt;
  name.vb: Dictionary(Of TKey, TValue)
</code></pre><p>This means the name of dictionary is <code>Dictionary&lt;TKey, TValue&gt;</code> in C# and <code>Dictionary(Of TKey, TValue)</code> in VB.</p>
<p>The following <em>properties</em> <strong>SHALL NOT</strong> be overridden in language context: uid, id, alias, children, and parent.</p>
<h2 id="3-work-with-metadata-in-markdown-">3. Work with Metadata in Markdown </h2>
<h3 id="31-yaml-metadata-section">3.1 YAML Metadata Section</h3>
<p>In a Markdown file, you can also define <em>items</em> using the same metadata syntax. The metadata definition <strong>MUST</strong> be in YAML format and enclosed by triple-dash lines (<code>---</code>).
Here is an example:</p>
<pre><code class="lang-markdown">---
uid: System.String
summary: String class
---

This is a **string** class.
</code></pre><p>You can have multiple YAML sections inside a single Markdown file, but in a single YAML section, there <strong>MUST</strong> be only one <em>item</em>.</p>
<p>The YAML metadata section does not have to contain all <em>properties</em>. The only <em>property</em> that <strong>MUST</strong> appear is &quot;uid&quot;, which is used to match the same <em>item</em> in metadata file.</p>
<p>The most common scenario for using YAML section is to specify which <em>item</em> the markdown doc belongs to. But you can also overwrite <em>item</em> <em>property</em> by defining one with the same name in YAML section. In the above example, the <em>property</em> &quot;summary&quot; will overwrite the same one in metadata.</p>
<p>As with language context, the following <em>properties</em> <strong>SHALL NOT</strong> be overridden: uid, id, alias, children, and parent.</p>
<p>You <strong>SHALL NOT</strong> define new <em>item</em> in Markdown.</p>
<h3 id="32-reference-items-in-markdown">3.2 Reference Items in Markdown</h3>
<p>To cross reference an <em>item</em>, you can use URI with <code>xref</code> scheme. You can either use <a href="https://daringfireball.net/projects/markdown/syntax#link">standard link</a> or <a href="https://daringfireball.net/projects/markdown/syntax#autolink">automatic link</a> with the above URI.
For example, to cross reference <code>System.String</code>:</p>
<pre><code class="lang-markdown">[System.String](xref:System.String)

&lt;xref:System.String&gt;
</code></pre><blockquote><p>Since <em>item</em> reference is a URI, special characters (like <code>#</code>, <code>?</code>) <strong>MUST</strong> be <a href="https://tools.ietf.org/html/rfc3986#section-2.1">encoded</a>.</p>
</blockquote>
<p>We also introduce a shorthand markdown syntax to cross reference easily:</p>
<p>If a string starts with <code>@</code>, and followed by a string enclosed by quotes <code>&#39;</code> or double quotes <code>&quot;</code>, it will be treated as an <em>item</em> reference. The string inside <code>&quot;&quot;</code> or <code>&#39;&#39;</code> is the <em>UID</em> of the <em>item</em>. Here is one example:</p>
<pre><code class="lang-markdown">@&quot;System.String&quot;
</code></pre><blockquote><p>Markdown processor <strong>MAY</strong> implement some algorithm to allow omit curly braces if <em>ID</em> is simple enough. For example, For reference like <code>@&quot;int&quot;</code>, we may also want to allow <code>@int</code>.</p>
</blockquote>
<p>When rendering references in Markdown, they will expand into a link with the <em>item</em>&#39;s name as link title. You can also customize the link title using the standard syntax of Markdown:</p>
<pre><code class="lang-markdown">[Dictionary](xref:System.Collections.Generic.Dictionary`2)&lt;[String](xref:System.String), [String](xref:System.String)&gt;
</code></pre><p>Will be rendered to:
<a href="xref:System.Collections.Generic.Dictionary`2">Dictionary</a>&lt;<a href="xref:System.String">String</a>, <a href="xref:System.String">String</a>&gt;</p>
<p>Besides <em>UID</em>, we also allow referencing items using <em>ID</em> and <em>alias</em>, in the Markdown processor, the below algorithm <strong>SHOULD</strong> be implemented to resolve references.</p>
<p>Check whether the reference matches:</p>
<ol>
<li>Any <em>identifier</em> of current <em>item</em>&#39;s children.</li>
<li>Any <em>alias</em> of current <em>item</em>&#39;s children.</li>
<li>Any <em>identifier</em> of current <em>item</em>&#39;s silbings.</li>
<li>Any <em>alias</em> of current <em>item</em>&#39;s silbings.</li>
<li>A <em>UID</em>.</li>
<li>A <em>global alias</em>.</li>
</ol>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dotnet/docfx/blob/doc/Documentation/spec/metadata_format_spec.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2016 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
